--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -26,7 +26,7 @@ set(SOURCE_SYSTEM ${SOURCE_ROOT}/System)
 
 # Compiler warning and optimization flags
 if(CMAKE_C_COMPILER_ID MATCHES "GNU")
-  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wno-class-memaccess")
+  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wall -Wno-class-memaccess -maes")
 endif()
 
 if (EMSCRIPTEN)
--- a/Source/C++/Crypto/Ap4AesBlockCipher.cpp
+++ b/Source/C++/Crypto/Ap4AesBlockCipher.cpp
@@ -1,3 +1,95 @@
+// https://gist.github.com/acapola/d5b940da024080dfaf5f
+#include <wmmintrin.h>
+
+struct aes_ctx { __m128i key_schedule[20]; };
+
+#define DO_ENC_BLOCK(m,k) \
+    do{\
+        m = _mm_xor_si128       (m, k[ 0]); \
+        m = _mm_aesenc_si128    (m, k[ 1]); \
+        m = _mm_aesenc_si128    (m, k[ 2]); \
+        m = _mm_aesenc_si128    (m, k[ 3]); \
+        m = _mm_aesenc_si128    (m, k[ 4]); \
+        m = _mm_aesenc_si128    (m, k[ 5]); \
+        m = _mm_aesenc_si128    (m, k[ 6]); \
+        m = _mm_aesenc_si128    (m, k[ 7]); \
+        m = _mm_aesenc_si128    (m, k[ 8]); \
+        m = _mm_aesenc_si128    (m, k[ 9]); \
+        m = _mm_aesenclast_si128(m, k[10]);\
+    }while(0)
+
+#define DO_DEC_BLOCK(m,k) \
+    do{\
+        m = _mm_xor_si128       (m, k[10+0]); \
+        m = _mm_aesdec_si128    (m, k[10+1]); \
+        m = _mm_aesdec_si128    (m, k[10+2]); \
+        m = _mm_aesdec_si128    (m, k[10+3]); \
+        m = _mm_aesdec_si128    (m, k[10+4]); \
+        m = _mm_aesdec_si128    (m, k[10+5]); \
+        m = _mm_aesdec_si128    (m, k[10+6]); \
+        m = _mm_aesdec_si128    (m, k[10+7]); \
+        m = _mm_aesdec_si128    (m, k[10+8]); \
+        m = _mm_aesdec_si128    (m, k[10+9]); \
+        m = _mm_aesdeclast_si128(m, k[0]);\
+    }while(0)
+
+#define AES_128_key_exp(k, rcon) aes_128_key_expansion(k, _mm_aeskeygenassist_si128(k, rcon))
+
+static __m128i aes_128_key_expansion(__m128i key, __m128i keygened)
+{
+    keygened = _mm_shuffle_epi32(keygened, _MM_SHUFFLE(3,3,3,3));
+    key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
+    key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
+    key = _mm_xor_si128(key, _mm_slli_si128(key, 4));
+    return _mm_xor_si128(key, keygened);
+}
+
+static void aes128_load_key(const unsigned char in_key[], unsigned int klen, aes_ctx cx[1])
+{
+    cx->key_schedule[0] = _mm_loadu_si128((const __m128i*) in_key);
+    cx->key_schedule[1]  = AES_128_key_exp(cx->key_schedule[0], 0x01);
+    cx->key_schedule[2]  = AES_128_key_exp(cx->key_schedule[1], 0x02);
+    cx->key_schedule[3]  = AES_128_key_exp(cx->key_schedule[2], 0x04);
+    cx->key_schedule[4]  = AES_128_key_exp(cx->key_schedule[3], 0x08);
+    cx->key_schedule[5]  = AES_128_key_exp(cx->key_schedule[4], 0x10);
+    cx->key_schedule[6]  = AES_128_key_exp(cx->key_schedule[5], 0x20);
+    cx->key_schedule[7]  = AES_128_key_exp(cx->key_schedule[6], 0x40);
+    cx->key_schedule[8]  = AES_128_key_exp(cx->key_schedule[7], 0x80);
+    cx->key_schedule[9]  = AES_128_key_exp(cx->key_schedule[8], 0x1B);
+    cx->key_schedule[10] = AES_128_key_exp(cx->key_schedule[9], 0x36);
+
+    // generate decryption keys in reverse order.
+    // k[10] is shared by last encryption and first decryption rounds
+    // k[0] is shared by first encryption round and last decryption round (and is the original user key)
+    // For some implementation reasons, decryption key schedule is NOT the encryption key schedule in reverse order
+    cx->key_schedule[11] = _mm_aesimc_si128(cx->key_schedule[9]);
+    cx->key_schedule[12] = _mm_aesimc_si128(cx->key_schedule[8]);
+    cx->key_schedule[13] = _mm_aesimc_si128(cx->key_schedule[7]);
+    cx->key_schedule[14] = _mm_aesimc_si128(cx->key_schedule[6]);
+    cx->key_schedule[15] = _mm_aesimc_si128(cx->key_schedule[5]);
+    cx->key_schedule[16] = _mm_aesimc_si128(cx->key_schedule[4]);
+    cx->key_schedule[17] = _mm_aesimc_si128(cx->key_schedule[3]);
+    cx->key_schedule[18] = _mm_aesimc_si128(cx->key_schedule[2]);
+    cx->key_schedule[19] = _mm_aesimc_si128(cx->key_schedule[1]);
+}
+
+static void aes_enc_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])
+{
+    __m128i m = _mm_loadu_si128((__m128i *) in_blk);
+    DO_ENC_BLOCK(m,cx->key_schedule);
+    _mm_storeu_si128((__m128i *) out_blk, m);
+}
+
+static void aes_dec_blk(const unsigned char in_blk[], unsigned char out_blk[], const aes_ctx cx[1])
+{
+    __m128i m = _mm_loadu_si128((__m128i *) in_blk);
+    DO_DEC_BLOCK(m,cx->key_schedule);
+    _mm_storeu_si128((__m128i *) out_blk, m);
+}
+
+#define aes_enc_key aes128_load_key
+#define aes_dec_key aes128_load_key
+
 /*
 * AES Block cipher
 * (c) 2005-2008 Axiomatic Systems,LLC
@@ -41,6 +133,7 @@ Issue Date: 29/07/2002
 #include "Ap4Utils.h"
 #include "Ap4Config.h"
 
+#if 0
 /*----------------------------------------------------------------------
 |   AES types
 +---------------------------------------------------------------------*/
@@ -1827,6 +1920,7 @@ static aes_rval aes_dec_blk(const unsigned char in_blk[], unsigned char out_blk[
     return aes_good;
 }
 
+#endif
 #endif
 
 /*----------------------------------------------------------------------
